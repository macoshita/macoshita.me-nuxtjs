---
title: rust memo
---

https://doc.rust-lang.org/book/second-edition/

## 3.1

let で変数定義 immutable
let mut で mutable
const で定数定義。実行時に計算するような値は入れられない。コードのあちこちで使うような値を入れる

```rust
let x = 5;
let x = x + 1;
```

↑シャドーイング。仮に let x = 5; x = x + 1; と書いたらイミュータブルだから怒られる

## 3.2

i8, i16, i32, i64 で signed な数
u8 - 64 で unsigned
isize, usize はアーキテクチャ任せ
tuple は let x: (i32, f64, u8) = (50, 3.2, 8); みたいに定義
x.0, x.1, x.2 でアクセス
let (a, b, c) = x; でスプレッド
配列は let a = [1,2,3];

## 4

```rust
let x = String::from("hoge");
let y = x;
println!("{}", x);
```

このコードはエラーになる。
shallow とか deep とかとも違い move といって、所有権が移動する
単純に let y = x.clone(); とすればうごく

```rust
let x = 1;
let y = x;
println!("{}", y);
```

このコードは動く。
Copy trait を持ってる型なら勝手にコピーしてくれる。
「なんとなく shallow copy とか deep copy にはならなそうだな」と思ったらでいけそう

```rust
let s1 = String::from("hello")
len = calc(s1)
println!("{}", s1)
fn calc(s: String) -> usize {
  s.len()
}
```

こうしちゃうと println でエラー。
所有権が calc にうつっちゃうのでもとのところでは使えない。
解決策として & つけて参照渡しする。
これを borrowing といい、値を借りてくる借り先を指定する。
借りてきた値も immutable なので、破壊的な操作は実行できない

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}
fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

mutable な操作をしたいならこう。


